<!DOCTYPE html>
<html>

<head>
  <title>Socket.IO chat</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=PT+Mono&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/css/index.css" />
</head>

<body <%- (typeof controls !='undefined' && controls) ? 'class="controller"' : '' %>>
  <div id="clock">
    <div class="display">
      <div class="time">00:00</div>
      <div class="progressBar"></div>
      <div class="round">Round <span class="currentRound">0</span> of <span class="totalRounds">0</span></div>

      <div class="title"> </div>
    </div>
  </div>
  <%- (typeof controls !='undefined' && controls) ? include('./partials/presets') : '' %>
    <script src="/socket.io/socket.io.js"></script>
    <script>
      var socket = io();

      var messages = document.getElementById('messages');
      var presets = document.getElementById('presets');
      var controls = document.getElementById('controls');
      var input = document.getElementById('input');
      let sequenceId;
      let jsInterval;
      let remaining;
      let autostart = false;

      var audio = new Audio('longbeep.mp3');
      audio.muted = true;

      const display = document.querySelector('#clock .display');
      const t = display.querySelector('.time');
      const roundsTotal = display.querySelector('.totalRounds');
      const currentRound = display.querySelector('.currentRound');
      const currentInterval = display.querySelector('.currentInterval');
      const progressBar = display.querySelector('.progressBar');
      const clock = document.getElementById('clock');

      function setProgress(index) {
        //  previous current is now past
        let prev = progressBar.querySelector('.current');
        prev.classList.remove('current');
        prev.classList.add('past');
        progressBar.querySelector(`[data-index="${index}"]`).classList.remove('future');
        progressBar.querySelector(`[data-index="${index}"]`).classList.add('current');
      }

      function setupClock(sequence) {
        if (!sequence.currentInterval) {
          setupTimer(sequence.intervals[0])
        } else {
          setupTimer(sequence.currentInterval);
        }
        currentRound.textContent = sequence.currentSet;
        roundsTotal.textContent = sequence.numberOfSets;

        progressBar.innerHTML = '';
        for (let i = 0; i < sequence.intervals.length; i++) {

          let progressTick = document.createElement('div');
          if (i == 0) {
            progressTick.classList.add('tick', 'current');
          } else {
            progressTick.classList.add('tick', 'future');
          }
          progressTick.style.width = 100 / sequence.intervals.length + '%';
          progressTick.dataset.index = i;
          progressBar.appendChild(progressTick);
          audio.muted = false;
        }

      }

      function setupTimer(interval) {
        clock.classList.forEach(className => {
          if (className.startsWith('color')) {
            clock.classList.remove(className);
          }
        });
        if (interval.color) clock.classList.add(`color-${interval.color}`);
        t.textContent = formatTime(interval.duration);
        t.dataset.duration = interval.duration;
        display.querySelector('.title').textContent = interval.name;
        if (interval.index) {
          setProgress(interval.index);
        }

        if (autostart) {
          jsInterval = startTimer();
        }
      }

      function stopTimer(jsInterval) {
        clearInterval(jsInterval);
      }

      function startTimer() {

        clock.classList.add('active');
        let duration = t.dataset.duration;

        var start = Date.now(),
          diff,
          minutes,
          seconds;
        function timer() {

          remaining = duration - (((Date.now() - start) / 1000) | 0);

          display.querySelector('.time').textContent = formatTime(remaining);


          if (remaining <= 0) {
            audio.play();
            clearInterval(jsInterval);
          }
        }
      

      // we don't want to wait a full second before the timer starts
      timer();
      clearInterval(jsInterval);
      jsInterval = setInterval(timer, 1000);
      return jsInterval;

      }

      function formatTime(duration) {
        // does the same job as parseInt truncates the float
        minutes = (duration / 60) | 0;
        seconds = (duration % 60) | 0;

        minutes = minutes < 10 ? "0" + minutes : minutes;
        seconds = seconds < 10 ? "0" + seconds : seconds;

        return minutes + ":" + seconds;
      }

      if (controls) {
        presets.addEventListener('click', function (e) {
          e.preventDefault();
          if (e.target.dataset.duration) {
            roundInput = document.querySelector('input[name="rounds"]');
            //        socket.emit('create timer', { duration: e.target.dataset.duration, rounds: roundInput.value });
          }
        });


        document.getElementById('startstop').addEventListener('click', function (e) {
          e.preventDefault();
          console.log(`fired ${e.target.dataset.action}`);
          if (e.target.dataset.action) {
            socket.emit(`${e.target.dataset.action} timer`);
            if (e.target.dataset.action == 'pause') {
              e.target.textContent = 'Resume';
              e.target.dataset.action = 'resume';
            } else if (e.target.dataset.action == 'resume') {
              e.target.textContent = 'Pause';
              e.target.dataset.action = 'pause';
            }
          }
        })
      }

      socket.on('stop timer', function (msg) {
        stopTimer(jsInterval);
      });

      socket.on('start timer', function (interval) {

        autostart = true;
        jsInterval = startTimer();
      });

      socket.on('setup interval', function (interval) {
        setupTimer(interval);
      });

      socket.on('setup clock', function (sequence) {
        setupClock(sequence);
      });

      socket.on('timer complete', function (e) {
        display.classList.remove('active');
      });

      socket.on('pause timer', function (e) {
        t.dataset.duration = remaining;
        clearInterval(jsInterval);
      });

      socket.on('resume timer', function (e) {
        jsInterval = startTimer();
      });

      socket.emit('fetch sequence', 'cirque');
    </script>
</body>

</html>